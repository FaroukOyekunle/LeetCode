Explanation

        -   We want to, after typing each character of searchWord, suggest up to three products from products that share the current prefix, in lexicographical order. To do this efficiently:

    -   Preprocessing (Sort the products)

        -   Sort products in ascending lexicographical order.

        -   This way, any contiguous block of matching prefixes will itself be lexicographically ordered.

    -   Typing each character

        -   Maintain a running prefix string.

        -   Each time we add one more character, we need to find all products that start with that updated prefix.

        -   Finding the start of matches with binary search

        -   Use a custom lowerâ€‘bound (first index where products[i] â‰¥ prefix lexicographically) via binary search.

        -   Call that index idx. Any product before idx is strictly less than the prefix and cannot match.

    -   Collect up to three suggestions

        -   Starting at products[idx], check at most the next three entries (or until we run out of array).

       -   For each, verify StartsWith(prefix). Stop scanning as soon as one doesnâ€™t match, since the array is sorted.

    -   Repeat for each prefix

        -   Append the list of up to three suggestions to our result.

        -   Continue until weâ€™ve processed every character of searchWord.

    -   Time Complexity

        -   Sorting: ğ‘‚(ğ‘logğ‘), ğ‘ = products.Length.

            For each of the ğ‘Š characters in searchWord:

        -   Binary search: ğ‘‚(logğ‘).

        -   Scanning up to 3 items: ğ‘‚(1).

        -   Total: ğ‘‚(ğ‘logğ‘ + ğ‘Šlogğ‘).

    -   Space Complexity

        -   Apart from the output lists, we use ğ‘‚(1) extra space.

